addAbsFC <- function(DF, FCCOL = "foldChange") {
	    # Adds a new column 'absFoldChange', by converting 
	    # negative fold change to positive
	    # provide the name of fold change column

    DF$absFoldChange <- DF[, FCCOL]
    FC <- DF[, FCCOL]
    POS <- which(FC < 1)
    DF$absFoldChange[POS] <- 1/FC[POS]
    DF
}

addByColFactor <- function(DATA, colVec = 1) {
	    # Creates a new DF
	    # aggregrates the data based on factors in a specific
	    # column, provide the index of column containing factors

    if (length(colVec) == 1) {
        REFERENCE <- DATA[, colVec]
    } else {
        REFERENCE <- apply(DATA[, colVec], 1, function(x) gsub(" ", "", 
            paste(x, collapse = "_")))
    }
    DATA <- DATA[, sapply(colnames(DATA), function(x) class(DATA[, x])) == 
        "numeric"]
    URNAME <- unique(REFERENCE)
    NEW <- colSums(DATA[REFERENCE == URNAME[1], ])
    for (RN in URNAME[2:length(URNAME)]) {
        NEW <- rbind(NEW, colSums(DATA[REFERENCE == RN, ]))
    }
    rownames(NEW) <- URNAME
    NEW
}

addFC <- function(DF, logFCCOL = "log2FoldChange", LOG = 2) {
	    # Adds a new column 'foldchange',  using data from logfoldchange column, 
	    # provide the name of logfoldchange column and base of log

    DF$foldChange <- LOG^DF[, logFCCOL]
    DF
}

addMGI4GenCode <- function(DF, GENE_MGI) {
	    # Adds a new column 'mgi_symbol' having MGI codes, using GENE_MGI mappings
	    # provide ENSEMBL GENE to MGI mappings

    DF$mgi_symbol <- GENE_MGI[gsub("[.][0-9]+$", "", rownames(DF), perl = TRUE)]
    DF
}

addUpDown <- function(DF, log2FCCOL = "log2FoldChange") {
	    # Adds an a new column 'regulation'
	    # with 'Up', 'Down' and 'Unchanged' labels  
	    # denoting up, down and unchanged genes

    DF$regulation <- DF[, log2FCCOL]
    FC <- DF[, log2FCCOL]
    POS <- which(FC < 0)
    DF$regulation[POS] <- "Down"
    POS <- which(FC > 0)
    DF$regulation[POS] <- "Up"
    POS <- which(FC == 0)
    DF$regulation[POS] <- "Unchanged"
    DF
}

GETSUM <- function(X, CountsOrig) {
    # Function to aggregate base on a pattern in column names
    # See calling function to understand this

    NUM <- grep(X, colnames(CountsOrig))
    if (length(NUM) > 1) {
        SUMMATION <- rowSums(CountsOrig[, NUM])
    } else {
        SUMMATION <- CountsOrig[, NUM]
    }
    SUMMATION
}

Map2List <- function(DATA, KEY, VAL) {
	    # Converts multiple mappings to a list

    LIST <- list()
    IDS <- sort(unique(DATA[, KEY]))
    for (ID in 1:length(IDS)) {
        VALUES <- DATA[DATA[, KEY] == IDS[ID], ][, VAL]
        VALUES <- unique(VALUES[VALUES != ""])
        if (length(VALUES) >= 1) {
            LIST[[ID]] <- unique(VALUES[VALUES != ""])
        }
    }
    names(LIST) <- IDS
    LIST
}

MergeGeneNamesInExpMat <- function(GTF, refGTF, COUNTS) {
	    # This function merges the novel genes which are actually mapping to,
	    # valid references
	    # Provide the GTF of the data and GTF of references

    novel2ref <- NOVEL2REF(GTF, refGTF)
    novel2ref <- novel2ref[grep("^MST", names(novel2ref))]
    RefNovelDF <- as.data.frame(cbind(reference = novel2ref, novel = names(novel2ref)))
    REFNAMES <- as.vector(unique(RefNovelDF$reference[RefNovelDF$novel %in% 
        rownames(COUNTS)]))
    REFNAMES <- REFNAMES[grep("^ENS", REFNAMES)]
    DELETEPOS <- c()
    NEWNAMES <- as.data.frame(t(sapply(REFNAMES, function(NAME, DF, RNAMES, 
        DATA) {
        pos <- which(RNAMES %in% c(NAME, as.vector(DF[DF$reference == NAME, 
            ]$novel)))
        DELETEPOS <<- c(DELETEPOS, pos)
        colSums(DATA[pos, ])
    }, DF = RefNovelDF, RNAMES = rownames(COUNTS), DATA = COUNTS)))
    COUNTS <- COUNTS[-DELETEPOS, ]
    rbind(COUNTS, NEWNAMES)
}

NOVEL2REF <- function(GTF, refGTF) {
	    # This function provides a map between novel to reference names
	    # Provide the GTF for the data and reference GTF
	    # this function has specific code that only works with output generated by Stringtie
	    # and reference genes with Ensembl identifiers

    if (class(refGTF) != "data.frame") {
        refGTF <- READGTF(refGTF)
    }
    GTF <- read.delim(GTF, header = FALSE, sep = "\t", comment.char = "#")
    colnames(GTF) <- c("sl", "db", "type", "start", "end", "x", "strand", 
        "y", "name")
    GTF <- GTF[GTF$type == "transcript", ]
    NAMES <- as.vector(GTF[, c("name")])
    novelNAMES <- gsub("gene_id (.*?);.*$", "\\1", NAMES)
    refNAMES <- gsub(".*?ref_gene_id (.*?);.*$", "\\1", NAMES)
    refNAMES <- gsub("gene_id (MSTRG[^ ]+); .*?$", "\\1", refNAMES)
    GTF <- GTF[, c("start", "end")]
    GTF$novelgene <- novelNAMES
    GTF$refgene <- refNAMES
    novelNAMES <- sort(unique(novelNAMES))
    novel2ref <- c()
    for (GENE in novelNAMES) {
        len <- 0
        MAXREF <- ""
        REFGENES <- unique(GTF[GTF$novelgene == GENE, ]$refgene)
        REFGENES <- REFGENES[grep("^ENS", REFGENES)]
        if (length(REFGENES) > 0) {
            for (REFGENE in REFGENES) {
                RECORD <- refGTF[REFGENE, ]
                LEN <- RECORD$end - RECORD$start
                if (LEN > len) {
                  len <- LEN
                  MAXREF <- REFGENE
                }
            }
            novel2ref <- c(novel2ref, MAXREF)
        } else {
            novel2ref <- c(novel2ref, GENE)
        }
    }
    names(novel2ref) <- novelNAMES
    novel2ref
}

PC <- function(VAR = "Progress", N = 0) {
		# Writes comment to stdout with correct indentation
	cat(paste(paste(replicate(N, "    "), collapse = ""), VAR, "    ", 
            "\n", sep = ""))
}

READGTF <- function(refGTF) {
	    # Reads a GTF file and returns a data frame with start and end values 
	    # row names as gene names
	    # provide the GTF file name 'refGTF'

    refGTF <- read.delim(refGTF, header = FALSE, sep = "\t", comment.char = "#")
    colnames(refGTF) <- c("sl", "db", "type", "start", "end", "x", "strand", 
        "y", "name")
    refGTF <- refGTF[refGTF$type == "gene", ]
    NAMES <- refGTF[, c("name")]
    NAMES <- gsub("gene_id (.*?);.*$", "\\1", NAMES)
    refGTF <- refGTF[, c("start", "end")]
    rownames(refGTF) <- NAMES
    refGTF
}

replaceDFColNAs <- function(DF, COLNAME, REPLACE) {
	    # This function replaces NAs in column 'COLNAME' with given replacement 'REPLACE'

    DF[, COLNAME][which(is.na(DF[, COLNAME]))] <- REPLACE
    DF
}

ReplaceEmptyMappings <- function(DF, SOURCE, TARGET) {
	    # This function replaces empty targets in the map with 
	    # Source identifiers
	    # Provide data frame and variables SOURCE and TARGET 
	    # whicha are column names of the data frame

    POS <- which(DF[, TARGET] == "")
    DF[, TARGET][POS] <- DF[, SOURCE][POS]
    POS <- which(DF[, TARGET] == "NA")
    DF[, TARGET][POS] <- DF[, SOURCE][POS]
    POS <- which(is.na(DF[, TARGET]))
    DF[, TARGET][POS] <- DF[, SOURCE][POS]
    DF
}

takeFirstCommonRow <- function(DATA, colVec = 1) {
	    # This function takes data from first common row, if there are multiple rows with same name
	    # Names of the data can be given by specifiying the column name/number or column names/numbers
	    # if multiple columns need to combined for concatenated names

    if (length(colVec) == 1) {
        REFERENCE <- DATA[, colVec]
    } else {
        REFERENCE <- apply(DATA[, colVec], 1, function(x) gsub(" ", "", 
            paste(x, collapse = "_")))
    }
    URNAME <- unique(REFERENCE)
    NEW <- DATA[REFERENCE == URNAME[1], ][1, ]
    for (RN in URNAME[2:length(URNAME)]) {
        NEW <- rbind(NEW, DATA[REFERENCE == RN, ][1, ])
    }
    NEW
}
# Sridhar A Malkaram (smalkaram@wvstateu.edu)
# Last modified on: 12/30/2017
